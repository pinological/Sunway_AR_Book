<!DOCTYPE html>
<html>
<head>
    <title>Harry Potter AR Brochure</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" />
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif; /* Changed to Inter for consistency */
            background-color: #000;
        }
        #ar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; /* AR content */
        }
        #interactive-iframe {
            position: absolute;
            border: none;
            /* TEMPORARY DEBUGGING: These lines MUST be commented out for debugging purposes */
            /* display: none; */
            /* opacity: 0; */
            z-index: 100; /* Always on top of the AR content */
            transform-origin: top left; /* Important for future potential CSS transforms */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background for iframe */
            box-shadow: 0 0 15px rgba(106, 13, 173, 0.8); /* Optional: add a glow */
            border-radius: 8px; /* Optional: rounded corners for the iframe */
            transition: opacity 0.3s ease-in-out; /* Smooth fade when appearing/disappearing */
            /* Ensure it has some initial size for debugging if display/opacity are commented out */
            width: 50vw; /* Debugging size */
            height: 50vh; /* Debugging size */
            top: 25vh; /* Debugging position */
            left: 25vw; /* Debugging position */
        }
        /* Message box for user feedback */
        #message-box {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
        }
        /* Loading spinner for camera/AI generation */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 2s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <!-- A-Frame library for building VR/AR experiences -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- MindAR.js library for AR capabilities -->
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
</head>
<body>
    <div id="message-box"></div>

    <div id="ar-container">
        <a-scene
            mindar-image="imageTargetSrc: ./targets.mind; debugUIEnabled: true;"
            color-space="sRGB"
            renderer="colorManagement: true, physicallyCorrectLights: true"
            vr-mode-ui="enabled: false"
            device-orientation-permission-ui="enabled: true" embedded
        >
            <a-assets>
                <!-- You can add 3D models, images, or other assets here if needed -->
            </a-assets>

            <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

            <!-- The target entity that MindAR.js will track -->
            <a-entity mindar-image-target="targetIndex: 0" id="brochure-target">
                <!-- A transparent plane that matches the size of your target image.
                     This plane's 3D position will be used to calculate the iframe's 2D screen position.
                     IMPORTANT: Adjust 'height' and 'width' to match the aspect ratio of your 'targets.mind' image!
                     For example, if your image is 1920x1080 (16:9 aspect ratio), you might use width="1" height="0.5625" (1 / 16 * 9)
                -->
                <a-plane id="tracked-plane" position="0 0 0" height="0.552" width="1" rotation="0 0 0" material="color: #6a0dad; opacity: 0.3;"></a-plane>

                <!-- You can also place other 3D content here if you wish, alongside the iframe -->
            </a-entity>
        </a-scene>
    </div>

    <!-- The iframe that will contain your interactive webpage content -->
    <iframe id="interactive-iframe" src="./interactive-content.html"></iframe>

    <script>
        // Function to display messages to the user
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('message-box');
            messageBox.innerHTML = message; // Use innerHTML to allow for spinner
            messageBox.style.display = 'block';
            if (duration > 0) { // Only hide if duration is positive
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, duration);
            }
        }

        const brochureTarget = document.querySelector('#brochure-target');
        const interactiveIframe = document.querySelector('#interactive-iframe');
        const trackedPlane = document.querySelector('#tracked-plane');
        const arScene = document.querySelector('a-scene');
        const arCamera = document.querySelector('a-camera');

        let cameraObj, renderer;
        let updateIframePositionRAF = null; // Use requestAnimationFrame for smoother updates

        // --- Camera and MindAR Initialization Feedback ---
        // This function attempts to get camera access and provides feedback.
        async function checkCameraAccess() {
            showMessage('Initializing camera... <div class="loader"></div>', 0); // Show indefinitely
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                console.log('Browser granted camera access.');
                // Stop the stream immediately as MindAR will handle it.
                stream.getTracks().forEach(track => track.stop());
                // Don't show "Camera ready!" yet, wait for MindAR's arReady event
            } catch (error) {
                console.error('Failed to get camera access:', error);
                let errorMessage = 'Camera access denied or not available.';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Camera permission denied. Please allow camera access in your browser settings.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'No camera found on this device.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'Camera is already in use by another application or device.';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = 'getUserMedia is not supported on this browser/device.';
                } else if (error.name === 'AbortError') {
                    errorMessage = 'Camera access was aborted (e.g., by user or system).';
                } else if (error.name === 'SecurityError') {
                    errorMessage = 'Camera access blocked due to security (e.g., not HTTPS).';
                }
                showMessage(`Camera Error: ${errorMessage}. Please ensure HTTPS and permissions are granted.`, 15000);
            }
        }

        // Listen for the A-Frame scene to be fully loaded before accessing Three.js objects
        arScene.addEventListener('loaded', () => {
            console.log('A-Frame scene loaded.');
            cameraObj = arCamera.getObject3D('camera');
            renderer = arScene.renderer;
            checkCameraAccess(); // Initiate camera check
        });

        // MindAR.js specific events for initialization status
        arScene.addEventListener('arReady', () => {
            console.log('MindAR.js is ready! Camera should be active.');
            showMessage('Camera ready! Point at your marker to see the content.', 5000);
        });

        arScene.addEventListener('arError', (event) => {
            console.error('MindAR.js AR Error:', event.detail);
            showMessage(`AR Initialization Error: ${event.detail.error.message || 'Unknown error'}. Check console.`, 15000);
        });
        // --- End Camera and MindAR Initialization Feedback ---


        // Function to get the 2D screen position and size of a 3D A-Frame entity's bounding box
        function getScreenPositionAndSize(entityEl, cameraObj, renderer) {
            // Ensure necessary objects are initialized and entity has a world matrix
            if (!cameraObj || !renderer || !entityEl.object3D || !entityEl.object3D.matrixWorld) {
                console.warn('getScreenPositionAndSize: Missing camera, renderer, or entity object3D.');
                return null;
            }

            // Update the entity's world matrix to reflect its current 3D position and rotation
            entityEl.object3D.updateMatrixWorld();

            const worldMatrix = entityEl.object3D.matrixWorld;

            // Get the actual width and height attributes of the A-Frame plane
            const planeWidth = parseFloat(entityEl.getAttribute('width'));
            const planeHeight = parseFloat(entityEl.getAttribute('height'));
            const halfWidth = planeWidth / 2;
            const halfHeight = planeHeight / 2;

            // Define the four corners of the plane in its local coordinates
            // (assuming the plane's origin is at its center)
            const corners = [
                new THREE.Vector3(-halfWidth, halfHeight, 0), // Top-left
                new THREE.Vector3(halfWidth, halfHeight, 0),  // Top-right
                new THREE.Vector3(-halfWidth, -halfHeight, 0), // Bottom-left
                new THREE.Vector3(halfWidth, -halfHeight, 0)   // Bottom-right
            ];

            const screenCorners = [];
            const tempVector = new THREE.Vector3(); // Re-use vector to avoid allocations

            // Project each corner to screen space
            for (let i = 0; i < corners.length; i++) {
                tempVector.copy(corners[i]);
                tempVector.applyMatrix4(worldMatrix); // Convert local to world coordinates
                tempVector.project(cameraObj); // Project world to NDC (Normalized Device Coordinates)

                // Convert NDC to screen pixels
                const screenX = (tempVector.x + 1) / 2 * window.innerWidth;
                const screenY = (-tempVector.y + 1) / 2 * window.innerHeight; // Y is inverted in screen space

                screenCorners.push({ x: screenX, y: screenY });
            }

            // Calculate bounding box in screen space
            const minX = Math.min(...screenCorners.map(c => c.x));
            const minY = Math.min(...screenCorners.map(c => c.y));
            const maxX = Math.max(...screenCorners.map(c => c.x));
            const maxY = Math.max(...screenCorners.map(c => c.y));

            const screenWidth = maxX - minX;
            const screenHeight = maxY - minY;

            // Check if the plane is facing the camera and has reasonable dimensions
            // If the plane is rotated away or too far, its screen dimensions might become very small or negative
            if (screenWidth <= 0 || screenHeight <= 0 || screenWidth > window.innerWidth * 2 || screenHeight > window.innerHeight * 2) {
                console.warn(`getScreenPositionAndSize: Invalid screen dimensions calculated: width=${screenWidth}, height=${screenHeight}. Returning null.`);
                return null; // Return null if dimensions are invalid, indicating it's not visible or badly oriented
            }

            return {
                x: minX,
                y: minY,
                width: screenWidth,
                height: screenHeight
            };
        }

        const updateIframePosition = () => {
            // Only update if the target is currently being tracked and camera/renderer are ready
            if (brochureTarget.components['mindar-image-target'].isTracking && cameraObj && renderer) {
                const rect = getScreenPositionAndSize(trackedPlane, cameraObj, renderer);
                console.log('Iframe target rect:', rect); // LOGGING THE RECT FOR DEBUGGING
                if (rect) { // Ensure valid dimensions
                    interactiveIframe.style.left = `${rect.x}px`;
                    interactiveIframe.style.top = `${rect.y}px`;
                    interactiveIframe.style.width = `${rect.width}px`;
                    interactiveIframe.style.height = `${rect.height}px`;
                    interactiveIframe.style.display = 'block'; // Ensure it's block to apply opacity
                    interactiveIframe.style.opacity = 1; // Fade in
                    console.log(`Iframe styled: left=${rect.x}, top=${rect.y}, width=${rect.width}, height=${rect.height}, opacity=1`); // More detailed log
                } else {
                    interactiveIframe.style.opacity = 0; // Fade out if dimensions are invalid (e.g., target too far or rotated away)
                    console.log('Iframe rect is null, setting opacity to 0.');
                }
            } else {
                interactiveIframe.style.opacity = 0; // Fade out if target not detected
                console.log('Target not tracking, setting iframe opacity to 0.');
            }
            updateIframePositionRAF = requestAnimationFrame(updateIframePosition);
        };

        brochureTarget.addEventListener('targetFound', () => {
            console.log('Brochure target found! Showing interactive content.');
            // interactiveIframe.style.display is now handled within updateIframePosition for smoother transitions
            if (!updateIframePositionRAF) {
                updateIframePositionRAF = requestAnimationFrame(updateIframePosition); // Start the update loop
            }
            // You can send a message to the iframe to notify it the target is found
            if (interactiveIframe.contentWindow) {
                interactiveIframe.contentWindow.postMessage('targetFound', '*');
            }
        });

        brochureTarget.addEventListener('targetLost', () => {
            console.log('Brochure target lost! Hiding interactive content.');
            interactiveIframe.style.opacity = 0; // Start fade out
            // Give it a moment to fade before hiding completely
            setTimeout(() => {
                interactiveIframe.style.display = 'none';
                if (updateIframePositionRAF) {
                    cancelAnimationFrame(updateIframePositionRAF);
                    updateIframePositionRAF = null;
                }
            }, 300); // Match transition duration
            // You can send a message to the iframe to notify it the target is lost
            if (interactiveIframe.contentWindow) {
                interactiveIframe.contentWindow.postMessage('targetLost', '*');
            }
        });

        // Optional: Listen for messages from the iframe
        window.addEventListener('message', (event) => {
            if (event.data === 'interactionComplete') {
                console.log('Received message from iframe: interactionComplete');
                // You could, for example, trigger a 3D animation here based on iframe interaction
            }
        });
    </script>
</body>
</html>
